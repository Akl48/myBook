# 问题

## _NULLable的使用
* _Nullable 表示对象可以是NULL或者nil 
  * 方法 `- (NSString * _Nullable)method;`
  * 属性 `@property(nonatomic ,copy)NSString * _Nullable str;`
* _nonull表示对象不应该为空。

## NS_ASSUME_NONNULL_BEGIN && NS_ASSUME_NONNULL_END
在新建一个类的时候把interface夹在中间 是为了让中间的对象不为空。

## strongify(self)&&weakify(self)
### __weak && __strong
在开发中，经常在控制器中用到block语句，在block语句中如果需引用self，而self（控制器）对象中又持有block对象，就会造成循环引用循环引用，导致内存泄露，比如以下代码
```objc
    self.block = ^{
        [self test];
    };
```
如果是通过__weak修饰的一个weakSelf变量指向self对象，并在block中使用weakSelf`__weak typeof(self) weakSelf = self;`
**但是这样子写有可能出问题，因为weakSelf是弱引用，而self一旦释放了，weakSelf可能为nil**
* 解决问题：再在这个block中把weakSelf给__strong一下`__strong typeof(weakSelf) strongSelf = weakSelf;`在使用这个strongSelf

### 宏定义
1. 在宏里也可以用...来表示多个参数，而__VA_ARGS__就对应多个参数的部分，例如：
    * > `define log(...) NSLog(__VA_ARGS__)`
2. ##是宏连接符，会将 ##左右两边连接起来，例如：
    * `#define XLink(n) x##n` ->@"xn" 

```objc
#ifndef weakify
    #if DEBUG
        #if __has_feature(objc_arc)
        #define weakify(object) autoreleasepool{} __weak __typeof__(object) weak##_##object = object;
        #else
        #define weakify(object) autoreleasepool{} __block __typeof__(object) block##_##object = object;
        #endif
    #else
        #if __has_feature(objc_arc)
        #define weakify(object) try{} @finally{} {} __weak __typeof__(object) weak##_##object = object;
        #else
        #define weakify(object) try{} @finally{} {} __block __typeof__(object) block##_##object = object;
        #endif
    #endif
#endif
```
@autoreleasepool{} **没有实际的意义**只是为了让@weakify显得更标准

## NS_UNAVAILABLE && NS_DESIGNATED_INITIALIZER
这两个关键字，是帮助约束定义方式，当有多个初始化的方法的时候，帮助外来者了解那个才是正确的初始化方法

### NS_DESIGNATED_INITALIZER
```objc
- (void)init;
- (void)initWithTitle:(NSString *)title;
- (void)initWithTitle:(NSString *)title date:(NSDate *)date;
```
`init`会调用`initWithTitle`之后他会调用`initWithTitle:date:`这样最后还是调用的最后这一个方法
对于这样能初始化全部必须变量的方法，一般可用作designed initalizer，所以最后告诉调用者他是这样一个初始化方法
`- (void)initWithTitle:(NSString *)title date:(NSDate *)date NS_DESIGNATED_INITIALIZER;`
* 一个子类如果有自己的designed initalizer那么**必须**实现父类的designed initalizer

### NS_UNAVAILABLE
在定义初始化方法时，除了能够用 NS_DESIGNATED_INITIALIZER 标记以外，还可以使用**更为强势**的 NS_UNAVAILABLE 。和 NS_DESIGNATED_INITIALIZER 用于明确初始化方法方式不同， NS_UNAVAILABLE 的作用是，**直接禁用当前的初始化方法**。

## xocde报错1
```
[AXMediaCommon] Unable to look up screen scale
[AXMediaCommon] Unexpected physical screen orientation
[AXMediaCommon] Unable to look up screen scale
[AXMediaCommon] Unable to look up screen scale
[AXMediaCommon] Unexpected physical screen orientation
```
## xcode报错2
`[framework] CUIThemeStore: No theme registered with id=0`
## 附带xib的初始化
有xib的viewController的初始化 `initWithNibName:@"ZTLoginViewController" bundle:nil`
xib问题之"..nib but the view outlet was not set."
1. 首先将xib的file's owner修改成相对应的viewController
2. 再将file's owner和当前的view连接
## UINavigationController初始化
必须在初始化的时候指定一个rootController，如果是被present出来的同样也可以在navigation的子视图中通过
`[self.navigationController dismissViewControllerAnimated:YES completion:nil]`直接在子视图中dismiss出去
## UIButton&UIImageView的圆角设置
```objc
self.button.layer.cornerRadius = CGFloat(10);
sellf.button.layer.masksToBounds = YES;
```
**问题**
由于这样处理的渲染机制是GPU在当前屏幕缓冲区外新开辟一个渲染缓冲区进行工作，也就是离屏渲染，这会给我们带来额外的性能损耗，如果这样的圆角操作达到一定数量，会触发缓冲区的频繁合并和上下文的的频繁切换，性能的代价会宏观地表现在用户体验上----掉帧
**解决方法**
在这里我是看过一个网上的介绍方法(http://www.cocoachina.com/articles/15655)如何避免GPU离屏渲染转向使用CPU处理（使用代价会小于上下文切换）觉得还不错。
1. 通过UIKit中对Core Graphics有一定封装的应用层类UIBezierPath，对图片进行破坏性的切角，破坏性仅仅是对切去部分而言，当然这操作是在CPU内完成的，而后我只需要取到处理完成的bitmap(可为UIImage对象)交给GPU显示于屏幕即可
```objc
- (void)ZTcornerRadiusWithImage:(UIImage *)image cornerRadius:(CGFloat)cornerRadius rectCornerType:(UIRectCorner)rectCornerType {
    CGSize size = self.bounds.size;
    CGFloat scale = [UIScreen mainScreen].scale;
    CGSize cornerRadii = CGSizeMake(cornerRadius, cornerRadius);
    UIGraphicsBeginImageContextWithOptions(size, NO, scale);
    if (nil == UIGraphicsGetCurrentContext()) {
        return;
    }
    UIBezierPath *cornerPath = [UIBezierPath bezierPathWithRoundedRect:self.bounds byRoundingCorners:rectCornerType cornerRadii:cornerRadii];
    [cornerPath addClip];
    [image drawInRect:self.bounds];
    self.image = UIGraphicsGetImageFromCurrentImageContext();
    UIGraphicsEndImageContext();
}
```
2. 由于大量的使用，所以要将这些抽取出来，可以通过category来实现
```objc
- (void)ZTcornerRadiusAdvance:(CGFloat)cornerRadius rectCornerType:(UIRectCorner)rectCornerType {
    objc_setAssociatedObject(self, &kRadius, @(cornerRadius), OBJC_ASSOCIATION_RETAIN_NONATOMIC);
    objc_setAssociatedObject(self, &kRoundingCorners, @(rectCornerType), OBJC_ASSOCIATION_RETAIN_NONATOMIC);
    objc_setAssociatedObject(self, &kIsRounding, @(0), OBJC_ASSOCIATION_RETAIN_NONATOMIC);
    [self.class swizzleMethod:@selector(layoutSubviews) anotherMethod:@selector(ZTLayoutSubviews)];
}
```
设置关联并之后在自定义ZTLayoutSubviews
```objc
- (void)ZTLayoutSubviews{
    [super layoutSubviews];
    NSNumber *radius = objc_getAssociatedObject(self, &kRadius);
    NSNumber *roundingCorners = objc_getAssociatedObject(self, &kRoundingCorners);
    [self ZT_cornerRadiusWithImage:self.image cornerRadius:radius.floatValue rectCornerType:roundingCorners.unsignedLongValue];
}
```
## UIButton的image和label的位置设置
```objc
- (void)setImageTitleMargin:(CGFloat)imageTitleMargin{
    [self.imageView sizeToFit];
    [self.titleLabel sizeToFit];
    
    CGFloat labelWidth = self.titleLabel.intrinsicContentSize.width; //注意不能直接使用titleLabel.frame.size.width
    CGFloat labelHeigth = self.titleLabel.intrinsicContentSize.height;
    CGFloat imageWidth = self.imageView.frame.size.width;
    CGFloat imageHeight = self.imageView.frame.size.height;
    
    self.titleEdgeInsets = UIEdgeInsetsMake(imageHeight/2 + imageTitleMargin/2, -imageWidth/2, -imageHeight/2 - imageTitleMargin/2, imageWidth/2);
    self.imageEdgeInsets = UIEdgeInsetsMake(-labelHeigth/2 - imageTitleMargin/2, labelWidth/2, labelHeigth/2 + imageTitleMargin/2, -labelWidth/2);    
}
```
```objc
typedef struct UIEdgeInsets {
    CGFloat top, left, bottom, right;  // specify amount to inset (positive) for each of the edges. values can be negative to 'outset'
} UIEdgeInsets;
```
UIEdgeInsert是一个结构体 而设置的是它的上下左右四边的偏移，UIEdgeInsertMake(20,0,0,0)即向下移动20;
## 设置点击键盘外导致键盘收起
```objc
- (void)touchesBegan:(NSSet<UITouch *> *)touches withEvent:(UIEvent *)event{
    UITouch *touch = touches.anyObject;
    if(!touch.view isKindOfClass:[UITextField class]){
        [self.view endEditing:YES];
    }
}
```
## UITextField代理监听长度
```objc
- (BOOL)textField:(UITextField *)textField shouldChangeCharactersInRange:(NSRange)range replacementString:(NSString *)string {
    if (textField.text.length == 11 && string.length >= 1) {
        self.phoneNumber = self.phoneTextField.text;
        return NO;
    }
    return YES;
}
```
## 支付宝快速登录
1. 需要参数
   1. 在支付宝中注册的appID
   2. 签约的支付宝账号对应的支付宝唯一用户号的pid
   3. 跳转之后返回的scheme
   4. authType 标识授权类型，取值范围：AUTHACCOUNT代表授权 LOGIN代表登录
2. 签名
   1. sign_type 商户生成签名字符串所使用的签名算法类型(RSA|RSA2推荐使用RSA2)
   2. sign 整个授权参数信息的签名，即此行以上参数key和value通过&拼接的字符串的签名值，对此字符串签名后需做URL编码
3. `-(void) auth_V2WithInfo:(NSString*)infoStr fromScheme(NSString*)schemeStr callback:(CompletionBlock)completionBlock;`
   1. 授权的方法
   2. 在infoStr中要明切所有信息，包括pid、addId、authtype
   3. 以及后来加上的&sign=%@&sign_type=%@ 签名以及签名方式
## 正则的书写（例如怎么实现一个电话号码的正则的判断）
## WKWebView的使用
### 添加进度条（KVO监听）
## 自定义转场动画
### 使用系统的present转场动画
```objc
typedef NS_ENUM(NSInteger, UIModalTransitionStyle) {
    UIModalTransitionStyleCoverVertical = 0,
    UIModalTransitionStyleFlipHorizontal __TVOS_PROHIBITED,
    UIModalTransitionStyleCrossDissolve,
    UIModalTransitionStylePartialCurl NS_ENUM_AVAILABLE_IOS(3_2) __TVOS_PROHIBITED,
}
```
系统自带的枚举类型大概有四种
```objc
    CATransition *animation = [CATransition animation];
    animation.duration = 0.75;
//    animation.timingFunction = UIViewAnimationCurveEaseInOut;
    animation.type = kCATransitionFromRight;
    animation.subtype = kCATransitionFromLeft;
    [self.view.window.layer addAnimation:animation forKey:nil];
```
## 
# 代码规范
## 类的布局
```objc
#pragma mark - Life Cycle
#pragma mark - Setup View / Data
#pragma mark - Observer
#pragma mark - Notification
#pragma mark - Event Response
#pragma mark - Override Methods
#pragma mark - Delegate
#pragma mark - Public Methods
#pragma mark - Private Methods
#pragma mark - Setter / Getter
#pragma mark - Network
```
## 初始化UI和Data
```objc
- (void)setupViews;
- (void)setupUI;
- (void)createUI;
- (void)configData;
- (void)setupData;
- (void)fetchData;
```
## 刷新UI
```objc
- (void)updateUI;
- (void)refreshUI;
- (void)reloadData;
- (void)refreshData;
```
