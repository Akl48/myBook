

[TOC]

# 计算机网络 

## 概述 

OSI七层模型 

物理层|数据链路层|网络层|传输层|会话层|表示层|应用层 

TCP/IP四层模型 

网络接口层|网际层|传输层|应用层 

## 传输层 

### TCP/UDP区别 

* TCP:面向连接，面向字节流，提供可靠交付，有流量控制，拥塞控制，只支持点对点交互通信，全工双通道。 

* UDP:无连接的，面向报文，经最大可能交付，支持一对一，多对多的交互通信。 

#### 如何通过UDP实现TCP的可靠传输 

1. 给数据包编号，按照包的顺序接收并存储 

2. 接收端接收到数据包后发送确认信息给发送端，发送端接收确认数据以后再继续发送下一个包，如果接收端收到的数据包的编号不是期望的编号，则要求发送端重新发送 

### TCP的三次握手 

1. 首先客户端给服务端发送请求连接的报文 ACK = 0 SYN = 以及一个随机序号seq = x; 

2. 再是服务端接受到客户端的报文，如果同意连接，则发送确认报文 ACK = 1,ack = x + 1,seq = y; 

3. 最后是客户端接受到服务器的确认报文之后发送确认 ack = y + 1 seq = x + 1 ACK = 1; 
   1. 建立连接

seq是序号，对字节流的编号 

ack是确认号，一般是seq + 1; 

#### 为什么是三次握手不是两次 

因为如果是**两次**握手，如果是客户端发送了一个**超时的报文**，之后服务端突然收到了就会建立连接，服务器会等待客户端的数据，这样会浪费资源。而如果是三次握手，由于之后客户端不会发送连接确认请求，服务器会自动关闭本次连接。 

### TCP四次挥手 

由于TCP连接是全双工的，所以每个方向都必须单独进行关闭。原则是一方完成了所有的数据传输之后就能发送一个FIN来终止这个方向的连接 

1. 客户端给服务器发送请求关闭连接的请求。FIN = 1 ,ACK = 0 ,seq = u; 

2. 服务器接受到这个FIN发回一个确认。ACK = 1,seq = v,ack = u + 1; 
   1. 此时TCP处于半关闭状态，只能服务器向客户端发送。

3. 当服务器不需要和客户端的连接之后，发回一个FIN。FIN = 1,ACK = 1,seq = w,ack = u + 1; 

4. 客户端发回ACK确认报文，ACK = 1,seq = u + 1,ack = w + 1; 
   1. 服务器接收到信息之后释放和客户端的连接

#### 为什么TIME_WAIT要等两个MSL在关闭 

1. 为了防止服务端收不到请求关闭连接的请求，则会在MSL时间内接收到超时重传的请求，再次发送。 

2. 可以保证本连接持续时间内所产生的所有报文都从网络中消失。 

### TCP滑动窗口 

TCP通过滑动窗口来实现，流量控制，控制发送方的发送速度。 

![屏幕快照 2019-04-23 下午4.26.02](/Users/zhoutianrong/MyDocument/myBook/photo/屏幕快照 2019-04-23 下午4.26.02.png)

### TCP的可靠传输 

TCP通过超时重传实现可靠传输，如果一个已经发送的报文段在超时时间内没有收到确认，就重新发送这个报文段。 

### TCP拥塞控制 

存在着四个算法 

#### 慢开始 

在发送的最开始只发送一个报文段 cwnd = 1，然后每次翻倍然后是2、4、8… 

#### 拥塞避免 

设置了一个慢开始的门限ssthresh，当cwnd>=ssthresh的时候 cwnd的增长速度每次只+1； 

* 当发生了超时重传的时候，令ssthresh = cwnd/2，然后重新开始慢开始。 

#### 快重传 

在收到三个重复报文之后，则知道是下一个报文段丢失，因此执行快重传，立刻重传下一个报文段。 

#### 快恢复 

由于是报文丢失而不是网络拥塞，则执行快恢复令ssthresh = cwnd/2 但是cwnd = ssthresh，直接进入拥塞避免 

## 应用层 

### DNS 

* DNS是一个分布式数据库，提供主机地址和IP地址的转化。这里的分布式数据库是指的是每个站点只保留自己的那部分数据。 

* DNS可以使用TCP或者UDP进行传输，但是大多数时间都是UDP。 

### FTP 

* FTP基于TCP的文件传输协议 

* 需要有两个连接来传输一个文件 
  * 控制连接 
  * 传输连接 

### DHCP 

提供了即插即用的联网方式，用户不用手动配置IP地址信息 

### TELNET（远程登陆协议） 

* 利用TCP登录到主机 

### 邮件传输协议 

全是基于TCP/IP 

#### SMTP 

只能发送ASCII 

#### POP3 

只要用户从服务器上读取了邮件，就把邮件删除 

#### IMAP 

协议中的邮件和服务器上的邮件保持同步 

## web请求的全过程 

### DHCP 配置主机信息 

1. 主机最开始没有IP地址以及其他的信息，需要通过DHCP获取 

2. 首先生成一个DHCP的请求报文。再封装到具有目的端口和源端口的UDP报文中 

3. 将报文段放入一个具有**广播IP目的地址**和**源IP地址**的IP数据报中 

4. 再将该数据报放置在MAC帧中，该帧具有目的地址，将广播到与交换机连接的所有设备 

5. 连接在交换机的DHCP的服务器收到广播帧之后，向上分解得到IP数据报，UDP数据报，DHCP请求报文，之后生成DHCP ACK报文，该报文包含以下信息：**IP地址**、**DNS服务器的IP地址**、**默认网关路由器的IP地址**和**子网掩码**。再类似的放在UDP报文中，IP报文中，最后放在MAC帧中。 

6. 该帧的目的地址是主机的MAC地址，由于交换机有路由表，所以可以直接发回。 

7. 主机收到该帧之后，不断分解得到DHCP报文，之后就配置它的IP地址，子网掩码和DNS服务器的IP地址，在其IP转发表中安装默认网关。 

### ARP 解析 MAC 地址 

1. 主机通过浏览器生成一个TCP的套接字，套接字向HTTP服务器发送HTTP请求。为了生成TCP套接字，主机要知道网站域名对应的IP地址 

2. 主机生成一个DNS查询报文，改报文具有53号端口，因为DNS服务器的端口是53。 

3. DNS查询报文被放到目的地址为DNS服务器IP地址的IP数据报中。 

4. IP数据报被放到了一个以太网帧，将该帧发送到网关路由器。 

5. DHCP只知道网关路由器的IP地址，为了获取网关路由器的MAC地址，还要使用ARP协议。 

6. 主机生成一个包含目的地址为网关路由器IP地址的ARP查询报文，将ARP查询报文放入一个具有广播目的地址的以太网帧中，并向交换机发送该以太网帧，交换机将该帧转发给所有的链接设备，包括网关路由器。 

7. 网关路由器接受到该帧之后，不断向上分解得到ARP报文，发现其中的IP地址和其接口的IP地址匹配，就返回一个ARP返回报文，包含了自己的MAC地址，发回给主机。 

### DNS 解析域名 

1. 知道了网关路由器的 MAC 地址之后，就可以继续 DNS 的解析过程了。 

2. 网关路由器接收到包含 DNS 查询报文的以太网帧后，抽取出 IP 数据报，并根据转发表决定该 IP 数据报应该转发的路由器。 

3. 因为路由器具有内部网关协议（RIP、OSPF）和外部网关协议（BGP）这两种路由选择协议，因此路由表中已经配置了网关路由器到达 DNS 服务器的路由表项。 

4. 到达 DNS 服务器之后，DNS 服务器抽取出 DNS 查询报文，并在 DNS 数据库中查找待解析的域名。 

5. 找到 DNS 记录之后，发送 DNS 回答报文，将该回答报文放入 UDP 报文段中，然后放入 IP 数据报中，通过路由器反向转发回网关路由器，并经过以太网交换机到达主机。 

### 最后一步 

1. 有了 HTTP 服务器的 IP 地址之后，主机就能够生成 TCP 套接字，该套接字将用于向 Web 服务器发送 HTTP GET 报文。 

2. 在生成 TCP 套接字之前，必须先与 HTTP 服务器进行三次握手来建立连接。生成一个具有目的端口 80 的 TCP SYN 报文段，并向 HTTP 服务器发送该报文段。 

3. HTTP 服务器收到该报文段之后，生成 TCP SYN ACK 报文段，发回给主机。 

4. 连接建立之后，浏览器生成 HTTP GET 报文，并交付给 HTTP 服务器。 

5. HTTP 服务器从 TCP 套接字读取 HTTP GET 报文，生成一个 HTTP 响应报文，将 Web 页面内容放入报文主体中，发回给主机。 

6. 浏览器收到 HTTP 响应报文后，抽取出 Web 页面内容，之后进行渲染，显示 Web 页面。 

## HTTP 

超文本传输协议用于从万维网服务器传输超文本到本地浏览器的传送协议，是建立于TCP协议之上的一种应用。 

### HTTP中发送请求的方法 

#### get&post 

GET 

在请求URL后面以?的形式跟上发给服务器的参数，多个参数之间用&隔开，比如 

http://ww.test.com/login?username=123&pwd=234&type=JSON 

由于浏览器和服务器对URL长度有限制，因此在URL后面附带的参数是有限制的，通常不能超过1KB 

POST 

发给服务器的参数全部放在请求体中 

理论上，POST传递的数据量没有限制（具体还得看服务器的处理能力） 

* 如果只是查询数据用get就可以了 

* 其他一般都使用post 

### 状态码 

1. 1XX 信息性状态码--接受的请求正在处理 

	1. 100 continue 

2. 2XX 成功--请求正常处理完毕 

	1. 200 OK 

3. 3XX 重定向--需要进行附加操作以完成请求 

	1. 301 永久重定向 

	2. 302 临时重定向 

3. 307 临时重定向 和302含义相似，但是307要求浏览器 

4. 4XX 客户端错误--服务器无法处理请求 

	1. 400 客户端请求有语法错误 

	2. 401 状态码表示发送的请求要有认证信息 

	3. 404 not Found 

5. 5XX 服务器错误--服务器处理请求出错 

	1. 500 服务器正在执行请求时发生错误 

	2. 503 服务器暂时处于超负载或正在进行停机维护 

### HTTP1.1和2.0 

HTTP1.1之后默认是长连接的，如果要断开就要客户端或者服务器提出断开。可以节省资源 

HTTP1.1之前是短连接的，每次请求数据都要新建一个TCP的长连接，开销会很大 

> 流水线 默认情况下HTTP是按顺序发出的，下个请求只有在当前响应之后才会发出，会被网络延迟和宽带限制，流水线是在同一长连接上发出连续的请求，而不用等待响应返回。 

**HTTP1.X的简单是通过牺牲性能作为代价的** 

HTTP2.0将报文分成头部和数据部两个部分，都是二进制。 

在通信过程中只有一个TCP连接存在，它承载了任意数量的双向数据流。 

在客户端请求一个资源之后会把相关资源一起发送，客户端就不用再次发起请求。 

HTTP2.0对首部使用Huffman进行压缩。 

#### Cookie 

HTTP1.1引入Cookie来保存状态信息。Cookie是服务器发送到用户浏览器并保存在本地的一块小数据，它会在浏览器之后向同一服务器再次发起请求时携带上但是现在逐渐被淘汰，**因为新的浏览器API可以允许开发者直接将数据储存到本地**。 

#### Session 

除了Cookie可以将用户信息储存在本地，也可以利用Session储存在服务器端，储存在服务器的信息更加安全。 

##### Cookie和Session 

1. Cookie 只能存储 ASCII 码字符串，而 Session 则可以存取任何类型的数据，因此在考虑数据复杂性时首选 Session； 

2. Cookie 存储在浏览器中，容易被恶意查看。如果非要将一些隐私数据存在 Cookie 中，可以将 Cookie 值进行加密，然后在服务器进行解密； 

3. 对于大型网站，如果用户所有的信息都存储在 Session 中，那么开销是非常大的，因此不建议将所有的用户信息都存储到 Session 中。 

### HTTPS 

使用 SSL（Secure Sockets Layer，安全套接层）和 TLS（Transport Layer Security，传输层安全）协议把通信内容加密后经网络隧道传输。 

#### 加密过程 

1. 对称加密 

	1. 加密和解密使用同一秘钥 

	2. 非对称加密 

		1. 加密和解密使用不同的秘钥 

		2. 公开秘钥所有人可以获得，再接收方接收到通信内容后使用私有秘钥解密。 

HTTPS使用混合加密机制，通过使用非对称秘钥加密用于传输对称秘钥来保证传输过程的安全性，之后使用对称秘钥进行通信来保证通信过程的效率 

#### 区别 

相比HTTP需要进行加密，速度会更慢 

需要支付证书授权的的高额费用 

# 网络工程

网络工程 == 计算机网络工程

> 计算机网络工程是在采用信息系统方法，在完善的组织机构引导下，根据用户的对数据、视频、语音 的等方面的应用需求，按照计算机网络系统的标准、规范和技术详细规划设计网络系统建设方案，将计算机网络设备、语音设备、视屏设备以及相关软件进行系统集成，建成一个满足用户需求、高效快速、安全稳定的计算机网络系统。

网络工程建设的组织机构：工程甲方 工程乙方 工程监理方

## 网络规划与设计大纲

1. 网络需求分析
2. 网络类型与规模分析
3. 网络分层与拓扑结构设计
4. IP地址规划、子网划分与VLAN设计
5. 网络中心设计
6. 网络工程综合布线设计
7. 网络安全与管理设计
8. 网络服务与应用设计
9. 网络设备选型