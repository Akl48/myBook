

[TOC]

# 操作系统 
操作系统是用户与计算机硬件之间的界面，它是控制和管理计算机系统内各种硬件和软件资源、有效地组织多道程序运行的程序集合。

## 进程和线程的区别 

1. 进程是资源分配的基本单位，但是线程不拥有资源，线程可以访问隶属进程的资源。 

2. 线程是独立调度的基本单位，在同一进程中，线程的切换不会引起进程的切换，从一个进程中的线程切换到另一个进程中的线程时，会引起进程的切换。 

3. 由于创建或者撤销进程的时候，系统都要为之分配或回收资源，开销远大于创建或者撤销线程时的开销。 
4. 线程之间的通信可以直接通过读写同一进程中的数据进行通信，但是进程通信需要IPC。 

### 进程的生命周期

![Process State](/Users/zhoutianrong/MyDocument/myBook/photo/Process State.png)

## 进程的调度算法 

### 批处理系统 

1. 先来先服务 first-come first-serverd（FCFS） 

   * 按照请求的顺序进行调度。 

   * 有利于长作业，但不利于短作业，因为短作业必须一直等待前面的长作业执行完毕才能执行，而长作业又需要执行很长时间，造成了短作业等待时间过长。 

2. 短作业优先 shortest job first（SJF） 

   * 按估计运行时间最短的顺序进行调度。 

   * 长作业有可能会饿死，处于一直等待短作业执行完毕的状态。因为如果一直有短作业到来，那么长作业永远得不到调度。 

3. 最短剩余时间优先 shortest remaining time next（SRTN） 
   * 按估计剩余时间最短的顺序进行调度。 

### 交互式系统 

交互式系统有大量的用户交互操作，在该系统中调度算法的目标是快速地进行响应。 

1. 时间片轮转 

   * 将所有就绪进程按 FCFS 的原则排成一个队列，每次调度时，把 CPU 时间分配给队首进程，该进程可以执行一个时间片。当时间片用完时，由计时器发出时钟中断，调度程序便停止该进程的执行，并将它送往就绪队列的末尾，同时继续把 CPU 时间分配给队首的进程。 

   * 时间片轮转算法的效率和时间片的大小有很大关系： 

   * 因为进程切换都要保存进程的信息并且载入新进程的信息，如果时间片太小，会导致进程切换得太频繁，在进程切换上就会花过多时间。而如果时间片过长，那么实时性就不能得到保证。
   * ![屏幕快照 2019-04-23 下午4.23.02](/Users/zhoutianrong/MyDocument/myBook/photo/屏幕快照 2019-04-23 下午4.23.02.png)

2. 优先级调度 

   * 为每个进程分配一个优先级，按优先级进行调度。 

   * 为了防止低优先级的进程永远等不到调度，可以随着时间的推移增加等待进程的优先级。 

3. 多级反馈队列 

   * 一个进程需要执行 100 个时间片，如果采用时间片轮转调度算法，那么需要交换 100 次。 

   * 多级队列是为这种需要连续执行多个时间片的进程考虑，它设置了多个队列，每个队列时间片大小都不同，例如 1,2,4,8,..。进程在第一个队列没执行完，就会被移到下一个队列。这种方式下，之前的进程只需要交换 7 次。 

   * 每个队列优先权也不同，最上面的优先权最高。因此只有上一个队列没有进程在排队，才能调度当前队列上的进程。 

   * 可以将这种调度算法看成是时间片轮转调度算法和优先级调度算法的结合。 
   * ![屏幕快照 2019-04-23 下午4.23.31](/Users/zhoutianrong/MyDocument/myBook/photo/屏幕快照 2019-04-23 下午4.23.31.png)

### 实时系统 

实时系统要一个请求在一个确定时间内得到响应 

分为硬实时、软实时，前者必须满足绝对的截止时间，后者可以容忍一定的超时。 

## 进程同步（锁） 

1. 临界区 
   1. 对临界资源进行访问的那段代码称为临界区。 
   2. 为了互斥访问临界资源，每个进程在进入临界区之前，需要先进行检查。 

2. 同步和互斥 
   1. 同步：多个进程按一定顺序执行 
   2. 互斥：多个进程在同一时刻只有一个进程能进入临界区 

3. 信号量 
   1. 信号量（Semaphore）是一个整型变量，可以对其执行 down 和 up 操作，也就是常见的 P 和 V 操作。 
   2. down : 如果信号量大于 0 ，执行 -1 操作；如果信号量等于 0，进程睡眠，等待信号量大于 0； 
   3. up ：对信号量执行 +1 操作，唤醒睡眠的进程让其完成 down 操作。 
   4. 如果信号量的取值只能为 0 或者 1，那么就成为了 互斥量（Mutex） ，0 表示临界区已经加锁，1 表示临界区解锁。 

4. 管程 
   1. 使用信号量机制实现的生产者消费者问题需要客户端代码做很多控制，而管程把控制的代码独立出来，不仅不容易出错，也使得客户端代码调用更容易。 

## 进程之间的通信 

> 进程通信和进程同步之间的区别 进程通信是一种手段，而进程同步是一种目的。可以说为了达到进程同步的目的，需要让进程进行通信。 

1. 管道 
   1. 管道是通过调用 pipe 函数创建的 
   2. ![屏幕快照 2019-04-23 下午4.23.53](/Users/zhoutianrong/MyDocument/myBook/photo/屏幕快照 2019-04-23 下午4.23.53.png)

2. FIFO 
   1. 也称为命名管道，去除了管道只能在父子进程中使用的限制。 
   2. ![屏幕快照 2019-04-23 下午4.24.10](/Users/zhoutianrong/MyDocument/myBook/photo/屏幕快照 2019-04-23 下午4.24.10.png)

3. 消息队列 
   1. 消息队列可以独立于读写进程存在，从而避免了 FIFO 中同步管道的打开和关闭时可能产生的困难； 
   2. 避免了 FIFO 的同步阻塞问题，不需要进程自己提供同步方法； 
   3. 读进程可以根据消息类型有选择地接收消息，而不像 FIFO 那样只能默认地接收。 

4. 信号量 
   1. 它是一个计数器，用于为多个进程提供对共享数据对象的访问。 

5. 共享储存 
   1. 允许多个进程共享一个给定的存储区。因为数据不需要在进程之间复制，所以这是最快的一种 IPC。 
   2. 需要使用信号量用来同步对共享存储的访问。 
   3. 多个进程可以将同一个文件映射到它们的地址空间从而实现共享内存。另外 XSI 共享内存不是使用文件，而是使用使用内存的匿名段。 

6. 套接字 
   1. 与其它通信机制不同的是，它可用于不同机器间的进程通信。 

## 栈和堆的区别 

1. 栈区（stack）— 由编译器自动分配释放 ，存放函数的参数值，局部变量的值等。其操作方式类似于数据结构中的栈。 
   1. 栈是向低地址扩展的数据结构，是一块连续的内存的区域 
   2. 栈的分配 
      1. 静态分配 
      2. 动态分配 

2. 堆区（heap） — 一般由程序员分配释放， 若程序员不释放，程序结束时可能由OS回收 。注意它与数据结构中的堆是两回事，分配方式倒是类似于链表。 
   1. 堆是向上地址扩展的数据结构，是一块不连续的内存区域 
   2. 堆的分配是动态分配 

## 死锁的情况 

死锁的四大要素 

1. 互斥：每个资源要么已经分配给了一个进程，要么就是可用的。 

2. 占有和等待：已经得到了某个资源的进程可以再请求新的资源。 

3. 不可抢占：已经分配给一个进程的资源不能强制性地被抢占，它只能被占有它的进程显式地释放。 

4. 环路等待：有两个或者两个以上的进程组成一条环路，该环路中的每个进程都在等待下一个进程所占有的资源。 

## 内存管理 

页面置换算法 

1. 在程序运行过程中，如果要访问的页面不在内存里，就发生缺页中断从而将该页掉入内存中。如果此时内存没有空闲空间，系统必须要从内存中调出一个页面到磁盘对换区中来腾出空间。 

2. 页面置换算法是为了是缺页中断率降到最低。 

3. 类似于在系统中内存是有限的，在有新的内存要使用的时候，就要淘汰一部分旧的占用的内存。 

### LRU 最近最久未使用 

1. 虽然无法知道将来要使用的页面的情况，但是可以知道过去页面的使用情况。**LRU**将最近最久未使用的页面换出。 

2. 为了实现LRU，需要在内存中维护一个所有页面的链表，当一个页面被访问的时候，这个页面移到链表表头，这样能保证，链表的结尾是最近最久未使用的。 

3. 但是由于要更新链表，因此这样的方式的代价很高。 

\### FIFO先进先出 

1. 选择置换出的页面是最先进入的页面。 

2. 改算法会将那些经常访问的页面也换出，是的缺页中断率高。 

### 第二次机会 

在FIFO之上的改进，在使用FIFO更换一个页面时，需要看一下该页面是否在最近被访问过，如果没有被访问过则替换该页面。反之，如果最近被访问过，则不替换该页面，而是将该页面挂到链表末尾，并修改该页面进入内存的时间为现在，并将访问位清零。 

### LFU 最不常用置换算法 

为每页设置一个访问计数器，当每页被访问的时候，计数器+1 

当发生缺页中断时，淘汰计数值最小的单位，并将所有计数器清零。 

# Linux

1. 在Linux/UNIX系统中，通常将**命令解释程序**称为**shell**
2. 红旗版本Linux系统默认的Shell是**bash**
3. **系统调用**是操作系统内核与用户程序、应用程序之间的接口

## Linux的特性

优点
1. 开放源码系统
2. 受到各国政府的大力支持
3.  得到全球各大软、硬件公司的支持：IBM,SUN,HP
4. 价格优势和安全

缺点

1. 不熟悉、应用软件少、使用不方便和功能不完备

## Linux的版本

核心版本主要是Linux的内核，由Linus本人维护

> 序号由三部分数字构成，其形式为
>  **major.minor.patchlevel**  //规定minor为奇数的时候是测试版不稳定|偶数为稳定版
>例如：2.2.11表示对核心2.2版本的第11次修订。

## Linux的分区

主分区|扩展分区|逻辑分区

1. 主分区 **一个硬盘最多只能有四个主分区**
   1. 硬盘分区表为64字节，每一个分区的信息占用16字节。因此主分区最多四个。
2. 扩展分区 **扩展分区主要是用于简历逻辑分区**
3. 逻辑分区 **就是扩展分区中的二级分区就是平常说的D盘E盘**

而Linux通过字母和数字的组合来标志硬盘分区

1. 前两个字母标志分区所在设备类型 (hd表示IDE硬盘|sd表示SCSI硬盘)
2. 第三个字母标志分区在那块硬盘上 (a表示1|b表示2|c表示3)
3. 最后的数字表示分区的次序，如数字1～4表示主分区或扩展分区，逻辑分区从5开始

安装Linux需要一个**根文件系统分区**（类型为 ext3、ext2 或 reiserfs）和一个**交换分区**（类型为swap）,这种分区方案适用于大多数用户。

**根分区**（/）：Linux 根文件系统驻留的地方。

**交换分区**（swap）：用来支持虚拟内存的交换空间，当没有足够的内存来处理系统数据时，就要使用交换分区的空间。交换分区的大小建议设置为计算机内存的1~2倍之间。

当需要将**硬盘划分为更多分区**时，可将其中一个**主分区**改为**扩展分区**。**扩展分区必须划分为逻辑分区**，**才能使用**。逻辑分区的编号从5开始。扩展分区最多1个。

### Linux中的shell

#### shell的建立

通过编辑器来录入和编辑如**vi**

通常用户不能直接执行由文本编辑器建立的shell脚本，因为直接编辑生成的脚本文件没有“执行”权限，

####shell的执行

1. 输入定向到shell脚本：$ bash > ex1
2. 以脚本名为bash参数 $ bash ex1 [参数]
3. 将shell脚本的权限设置为可执行，然后在提示符下直接执行它，要用chmod命令将其设置为有“执行”权限 
   1. $ chmod a+x ex2  修改权限为可执行
   2. $ ex2 执行ex2

#### 命令历史

> history [参数] 
>
> 参数：-a 在历史文件中添加新的历史命令行
>
> ​		：-c 删除历史清单中所有的项

#### 执行历史命令

执行历史命令是**命令替换之一**，它以字符"!"开头、后随1个或多个字符，用来定义用户所需的某种类型的历史命令。

* !!重复执行上一条命令==!-1

* !1重复执行第1条历史命令
* !-1重复执行倒数第1条命令
* !string执行以字符串string开头的历史命令
* !?string?执行包含字符串string的历史命令

#### 别名

> alias [name[=value]]

1. 使用单引号 
2. 等号两边不能有空格

##### 取消别名

unalise name…

-a 取消全部

### shell的特殊字符

1. 一般通配符
   1. *匹配任意字符0次多次出现
   2. ？能匹配任意字符
2. 引号
   1. ``倒引号括起来的字符串被shell认为是命令行，先执行该命令行，并以它的标准输出结果取代整个倒引号部分
   2. 由单双引号括起来的都以普通字符对待
3. \反斜杠转义字符 可以将特殊字符变成普通字符

### 重定向符号

#### 输入重定向

> \<把命令的标准输入定向到指定的文件
>
> 命令 < 文件 文件中是经常执行的shell文件

#### 输出重定向

> \>把命令的标准输出重新定向到指定的文件
>
> 命令 > 文件
>
> **who >** abc 将who的结果输入到abc文件中

** 输入和输出重定向可以一起使用 **

wc  -l \< infile \>outfile

命令从infile中输入信息，统计之后输出结果到outfile文件中

#### 输出附加定向符

把命令的标准输出附加到指定文件的后面，原有内容不变

> 命令\>\>文件

#### 标准错误输出也可重定向

>$ 命令 \>2文件名
>
>$ 命令 \>\>2 文件名

\>2 中间没有空格

例如$gcc m1.c >2 abc

将编译m1.c的错误重定向输出到abc

# 科学上网
## 购买VPS

略

## 安装Google的BBR加速算法
使用root身份登录你的vps，输入下面命令就自动安装BBR算法。
wget –no-check-certificate https://github.com/teddysun/across/raw/master/bbr.sh
chmod +x bbr.sh
./bbr.sh
安装后，建议重启一次服务器生效。

## 安装ShadowSocks
> wget –no-check-certificate  https://raw.githubusercontent.com/teddysun/shadowsocks_install/master/shadowsocks.sh
> ./shadowsocks.sh 2>&1 | tee shadowsocks.log
按照顺序安装即可