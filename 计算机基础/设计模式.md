# 设计模式

## iOS中的设计模式

[来自BLOG](https://www.jianshu.com/p/2ad25e2769b5)

### MVC

在iOS中的MVC是很难达到标准的MVC的，因为在每个viewController中都有一个自己的self.view，这就导致了controller和view的高耦合在了VC里面。这就造成了VC中的代码量很大，**主要是错误的**因为我们对于view和model层的职责都划分的比较清楚，前者负责数据展示，后者负责数据获取，那么那些模棱两可的代码，放在这两层感觉都不合适，就都丢到了VC里面，导致VC日益膨胀。

#### 正确的MVC

Model层:里面要完成对使用的**网络协议**(HTTP, TCP，其他)、和服务器之间交互的**数据格式**（XML, JSON,其他)、**本地缓存**和**数据库存储**（COREDATA, SQLITE,其他)等所有业务细节的封装，而且这些东西都不能暴露给C层。所有供C层调用的都是M层里面一个个业务类所提供的成员方法来实现(Model层不应该是数据模型，不是放几个属性就完事了。而应该是承载业务逻辑和数据存储获取的职责一层)。

View层：界面元素的展示，数据的展示，接受用户操作并反馈动画

Controller层:
    1. view的生成、组装
    2. view的声明周期的控制
    3. 相应view的点击，作为view的代理
    4. 从Model层获取数据，处理加工渲染到view层
    5. 处理页面之间的跳转

#### 问题

最大的问题就是c层无法复用，导致了**业务逻辑和业务展示高度耦合**，无法单元测试，必须等页面展示之后，才能继续测试。

### MVP

MVP的提出就是为了解决MVC中的逻辑和展示过于耦合在vc中，添加了一个P层，变成了MVCP

MVP从视图层中分离了行为（事件响应）和状态（属性，用于数据展示），它创建了一个视图的抽象，也就是presenter层，而视图就是P层的『渲染』结果。P层中包含所有的视图渲染需要的动态信息，包括视图的内容（text、color）、组件是否启用（enable），除此之外还会将一些方法暴露给视图用于某些事件的响应。

controller层
    1. view的声明周期的控制
    2. 绑定view和presenter层
    3. 调用p层执行业务逻辑
presenter层
    1. 里面放着业务逻辑、同时也是视图的代理，所有相关的交互事件交给p层来做。
    2. 从model接口获取数据，并且封装成view可用的模式
view层
    1. 监听P层的数据更新通知，刷新view（原本为c中控制）
    2. 点击事件触发，调用P层的方法，并将结果展示

这样View就会和present有两种实现方式

1. view作为被动方，由present持有view然后对view进行数据的展示，但是这样就和vc的效果类似了。
2. 由view来持present，让present只做业务的逻辑，保证了p层的纯粹

#### 被动视图模式MVP

视图层是被动的，它本身不会改变自己的任何的状态，它只是定义控价的样式和布局，本身是没有任何逻辑的，这就让view层达到了复用的效果。

1. 当视图接收到来自用户的事件时，会将事件转交给 Presenter 进行处理；
2. 被动的视图实现presentr的代理，当需要更新视图时 Presenter回调代理来更新视图的内容，这样让presenter专注于业务逻辑，view专注于显示逻辑
3. Presenter 负责对模型进行操作和更新，在需要时取出其中存储的信息；
4. 当模型层改变时，可以将改变的信息发送给观察者 Presenter

#### 监督控制器模式MVP

视图层接管了一部分视图逻辑，主要就是同步简单的视图和模型的状态；而监督控制器就需要负责响应用户的输入以及一部分更加复杂的视图、模型状态同步工作。（但是数据的绑定展示，有点类似语MVVM中的双向绑定实现两者的相互映射）

### MVVM

基于MVP之上，MV层就类似于P层，而改进的地方是添加数据的双向绑定。可以通过RAC来是实现，让当前的代码量更少了。

### VIPER

VIPER是一种更彻底的方式，不同于MVX系列，将VC划分的更彻底了。

1. Interactor（交互器） - 这是应用程序的主干，因为它包含应用程序中用例描述的业务逻辑。交互器负责从数据层获取数据，并执行特定场景下的业务逻辑，其实现完全独立于用户界面。
2. Presenter（展示器） - 它的职责是从用户操作的Interactor获取数据，创建一个Entities实例，并将其传送到View以显示它。
3. Entities（实体） - 纯粹的数据对象。不包括数据访问层，因为这是 Interactor 的职责。
4. Router（路由） - 负责 VIPER 模块之间的跳转
5. View（视图）- 视图的责任是将用户操作发送给演示者，并显示presenter告诉它的任何内容
**数据的获取应该单独放在一个层datamanager中而不是放在交互器中**

> 一般开发中除了VIPER这五层，一般还有protocal。
> protocal定义每层需要遵循的协议，每层对外暴露的操作都经过protocol抽象了，这样可以针对抽象编程。

### 单例设计模式

单例一旦创建，**整个App使用过程都不会释放**，这会占用内存，因此不可滥用单例
只有整个全局都只需要一个对象的时候才能使用单例（网络请求AFNetWorking）
