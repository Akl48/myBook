# Objective-C

简称OC，在C语言的基础上添加了**面对对象**的特性。

## 了解OC

OC的起源，在OC中频繁的使用[]方括号，是因为在OC中存在着特殊的**消息机制**，而不是**函数调用**。

**消息机制**：其运行时，不管是否多态，总是在运行时才会去查找所要执行的方法，实际上编译器不会去关心接受对象是什么类型，因为接受消息的对象问题也要在运行时考虑，这个过程是**动态绑定**。

* OC中所有重要工作都由**运行时组件**而非编译器完成。

### OC中的栈和堆

在OC中会经常声明一个NSString* str = @"hello world";这样的语句

1. 声明的是一个指向NSString* 的指针而OC中的所有对象都要这样声明

2. 在内存中的栈区声明了一个NSString* 型的指针

3. 在内存中的堆中分配的NSString对象

4. 分配在栈中的保存变量的内存会自动清理

5. 分配在堆中的内存要手动管理-但是OC将这部分抽象出来形成了引用计数

有时候会遇到定义中不含* 的变量他们可能会使用栈空间，例如CoreGraphics框架中的CGRect等。

### OC中的头文件操作

* 在OC中的有时候使用一个Person类的文件的时候，不需要知道Person的全部细节，只要知道有这个类就行了这个时候只用在头文件中声明@class Person 就可以告诉编译器————————这样的情况叫前向声明。

* 而在实现文件中，如果要知道其全部细节，则要在实现文件中加入头文件。

> 向前声明解决了两个类相互引用的问题，要引用会在各个头文件中引入了对方的文件。而使用import虽然不会像include一样导致死循环，但是意味着有一个无法正确编译，也降低了类之间的耦合.

## KVC&&KVO

### KVC的原理

KVC的底层实现

#### set

1. 程序先调用set:属性名设置，然后代码通过setter方法完成设置
2. 如果没有找到setter方法，KVC会检查`+(BOOL)accessInstanceVariablesDirectly`方法来检查有没返回yes
   1. 默认返回yes到第3步
   2. 如果在类中重写类方法直接跳到第5步
3. 在类中通过`_key`来访问
4. 还是不行的话通过`_iskey`来访问
5. 最后调用`setValue：forUndefinedKey`曝出异常

#### get

1. 如果是BOOL或者int类型会包装成NSNumber对象
2. KVO也会检查`+(BOOL)accessInstanceVariablesDirectly`
3. 最后还是调用`valueForUndefinedKey:`返回一个异常

### KVC处理nil异常

通常就由`setNilValueForKey`来抛出空异常
所以解决方法：**重写这个方法**

### KVO的原理

KVO 是通过 isa-swizzling 实现的。
基本的流程就是编译器自动为被观察对象创造一个派生类，并将被观察对象的isa 指向这个派生类。如果用户注册了对某此目标对象的某一个属性的观察，那么此派生类会重写这个方法，并在其中添加进行通知的代码。Objective-C 在发送消息的时候，会通过 isa 指针找到当前对象所属的类对象。而类对象中保存着当前对象的实例方法，因此在向此对象发送消息时候，实际上是发送到了派生类对象的方法。由于编译器对派生类的方法进行了 override，并添加了通知代码，因此会向注册的对象发送通知。注意派生类只重写注册了观察者的属性方法。

![KVO](../photo/KVO.png)
