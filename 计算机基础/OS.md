

[TOC]

# 操作系统 

## 进程和线程的区别 

1. 进程是资源分配的基本单位，但是线程不拥有资源，线程可以访问隶属进程的资源。 

2. 线程是独立调度的基本单位，在同一进程中，线程的切换不会引起进程的切换，从一个进程中的线程切换到另一个进程中的线程时，会引起进程的切换。 

3. 由于创建或者撤销进程的时候，系统都要为之分配或回收资源，开销远大于创建或者撤销线程时的开销。 
4. 线程之间的通信可以直接通过读写同一进程中的数据进行通信，但是进程通信需要IPC。 

### 进程的生命周期

![Process State](/Users/zhoutianrong/MyDocument/myBook/photo/Process State.png)

## 进程的调度算法 

### 批处理系统 

1. 先来先服务 first-come first-serverd（FCFS） 

   * 按照请求的顺序进行调度。 

   * 有利于长作业，但不利于短作业，因为短作业必须一直等待前面的长作业执行完毕才能执行，而长作业又需要执行很长时间，造成了短作业等待时间过长。 

2. 短作业优先 shortest job first（SJF） 

   * 按估计运行时间最短的顺序进行调度。 

   * 长作业有可能会饿死，处于一直等待短作业执行完毕的状态。因为如果一直有短作业到来，那么长作业永远得不到调度。 

3. 最短剩余时间优先 shortest remaining time next（SRTN） 
   * 按估计剩余时间最短的顺序进行调度。 

### 交互式系统 

交互式系统有大量的用户交互操作，在该系统中调度算法的目标是快速地进行响应。 

1. 时间片轮转 

   * 将所有就绪进程按 FCFS 的原则排成一个队列，每次调度时，把 CPU 时间分配给队首进程，该进程可以执行一个时间片。当时间片用完时，由计时器发出时钟中断，调度程序便停止该进程的执行，并将它送往就绪队列的末尾，同时继续把 CPU 时间分配给队首的进程。 

   * 时间片轮转算法的效率和时间片的大小有很大关系： 

   * 因为进程切换都要保存进程的信息并且载入新进程的信息，如果时间片太小，会导致进程切换得太频繁，在进程切换上就会花过多时间。而如果时间片过长，那么实时性就不能得到保证。
   * ![屏幕快照 2019-04-23 下午4.23.02](/Users/zhoutianrong/MyDocument/myBook/photo/屏幕快照 2019-04-23 下午4.23.02.png)

2. 优先级调度 

   * 为每个进程分配一个优先级，按优先级进行调度。 

   * 为了防止低优先级的进程永远等不到调度，可以随着时间的推移增加等待进程的优先级。 

3. 多级反馈队列 

   * 一个进程需要执行 100 个时间片，如果采用时间片轮转调度算法，那么需要交换 100 次。 

   * 多级队列是为这种需要连续执行多个时间片的进程考虑，它设置了多个队列，每个队列时间片大小都不同，例如 1,2,4,8,..。进程在第一个队列没执行完，就会被移到下一个队列。这种方式下，之前的进程只需要交换 7 次。 

   * 每个队列优先权也不同，最上面的优先权最高。因此只有上一个队列没有进程在排队，才能调度当前队列上的进程。 

   * 可以将这种调度算法看成是时间片轮转调度算法和优先级调度算法的结合。 
   * ![屏幕快照 2019-04-23 下午4.23.31](/Users/zhoutianrong/MyDocument/myBook/photo/屏幕快照 2019-04-23 下午4.23.31.png)

### 实时系统 

实时系统要一个请求在一个确定时间内得到响应 

分为硬实时、软实时，前者必须满足绝对的截止时间，后者可以容忍一定的超时。 

## 进程同步（锁） 

1. 临界区 
   1. 对临界资源进行访问的那段代码称为临界区。 
   2. 为了互斥访问临界资源，每个进程在进入临界区之前，需要先进行检查。 

2. 同步和互斥 
   1. 同步：多个进程按一定顺序执行 
   2. 互斥：多个进程在同一时刻只有一个进程能进入临界区 

3. 信号量 
   1. 信号量（Semaphore）是一个整型变量，可以对其执行 down 和 up 操作，也就是常见的 P 和 V 操作。 
   2. down : 如果信号量大于 0 ，执行 -1 操作；如果信号量等于 0，进程睡眠，等待信号量大于 0； 
   3. up ：对信号量执行 +1 操作，唤醒睡眠的进程让其完成 down 操作。 
   4. 如果信号量的取值只能为 0 或者 1，那么就成为了 互斥量（Mutex） ，0 表示临界区已经加锁，1 表示临界区解锁。 

4. 管程 
   1. 使用信号量机制实现的生产者消费者问题需要客户端代码做很多控制，而管程把控制的代码独立出来，不仅不容易出错，也使得客户端代码调用更容易。 

## 进程之间的通信 

> 进程通信和进程同步之间的区别 进程通信是一种手段，而进程同步是一种目的。可以说为了达到进程同步的目的，需要让进程进行通信。 

1. 管道 
   1. 管道是通过调用 pipe 函数创建的 
   2. ![屏幕快照 2019-04-23 下午4.23.53](/Users/zhoutianrong/MyDocument/myBook/photo/屏幕快照 2019-04-23 下午4.23.53.png)

2. FIFO 
   1. 也称为命名管道，去除了管道只能在父子进程中使用的限制。 
   2. ![屏幕快照 2019-04-23 下午4.24.10](/Users/zhoutianrong/MyDocument/myBook/photo/屏幕快照 2019-04-23 下午4.24.10.png)

3. 消息队列 
   1. 消息队列可以独立于读写进程存在，从而避免了 FIFO 中同步管道的打开和关闭时可能产生的困难； 
   2. 避免了 FIFO 的同步阻塞问题，不需要进程自己提供同步方法； 
   3. 读进程可以根据消息类型有选择地接收消息，而不像 FIFO 那样只能默认地接收。 

4. 信号量 
   1. 它是一个计数器，用于为多个进程提供对共享数据对象的访问。 

5. 共享储存 
   1. 允许多个进程共享一个给定的存储区。因为数据不需要在进程之间复制，所以这是最快的一种 IPC。 
   2. 需要使用信号量用来同步对共享存储的访问。 
   3. 多个进程可以将同一个文件映射到它们的地址空间从而实现共享内存。另外 XSI 共享内存不是使用文件，而是使用使用内存的匿名段。 

6. 套接字 
   1. 与其它通信机制不同的是，它可用于不同机器间的进程通信。 

## 栈和堆的区别 

1. 栈区（stack）— 由编译器自动分配释放 ，存放函数的参数值，局部变量的值等。其操作方式类似于数据结构中的栈。 
   1. 栈是向低地址扩展的数据结构，是一块连续的内存的区域 
   2. 栈的分配 
      1. 静态分配 
      2. 动态分配 

2. 堆区（heap） — 一般由程序员分配释放， 若程序员不释放，程序结束时可能由OS回收 。注意它与数据结构中的堆是两回事，分配方式倒是类似于链表。 
   1. 堆是向上地址扩展的数据结构，是一块不连续的内存区域 
   2. 堆的分配是动态分配 

## 死锁的情况 

死锁的四大要素 

1. 互斥：每个资源要么已经分配给了一个进程，要么就是可用的。 

2. 占有和等待：已经得到了某个资源的进程可以再请求新的资源。 

3. 不可抢占：已经分配给一个进程的资源不能强制性地被抢占，它只能被占有它的进程显式地释放。 

4. 环路等待：有两个或者两个以上的进程组成一条环路，该环路中的每个进程都在等待下一个进程所占有的资源。 

## 内存管理 

页面置换算法 

1. 在程序运行过程中，如果要访问的页面不在内存里，就发生缺页中断从而将该页掉入内存中。如果此时内存没有空闲空间，系统必须要从内存中调出一个页面到磁盘对换区中来腾出空间。 

2. 页面置换算法是为了是缺页中断率降到最低。 

3. 类似于在系统中内存是有限的，在有新的内存要使用的时候，就要淘汰一部分旧的占用的内存。 

### LRU 最近最久未使用 

1. 虽然无法知道将来要使用的页面的情况，但是可以知道过去页面的使用情况。**LRU**将最近最久未使用的页面换出。 

2. 为了实现LRU，需要在内存中维护一个所有页面的链表，当一个页面被访问的时候，这个页面移到链表表头，这样能保证，链表的结尾是最近最久未使用的。 

3. 但是由于要更新链表，因此这样的方式的代价很高。 

\### FIFO先进先出 

1. 选择置换出的页面是最先进入的页面。 

2. 改算法会将那些经常访问的页面也换出，是的缺页中断率高。 

### 第二次机会 

在FIFO之上的改进，在使用FIFO更换一个页面时，需要看一下该页面是否在最近被访问过，如果没有被访问过则替换该页面。反之，如果最近被访问过，则不替换该页面，而是将该页面挂到链表末尾，并修改该页面进入内存的时间为现在，并将访问位清零。 

### LFU 最不常用置换算法 

为每页设置一个访问计数器，当每页被访问的时候，计数器+1 

当发生缺页中断时，淘汰计数值最小的单位，并将所有计数器清零。 