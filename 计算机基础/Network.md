# 计算机网络

## 概述

1. OSI七层模型
物理层|数据链路层|网络层|传输层|会话层|表示层|应用层

2. TCP/IP四层模型
网络接口层|网际层|传输层|应用层

## 传输层

### TCP/UDP区别

* TCP:面向连接，面向字节流，提供可靠交付，有流量控制，拥塞控制，只支持点对点交互通信，全工双通道。
* UDP:无连接的，面向报文，经最大可能交付，支持一对一，多对多的交互通信。

#### 如何通过UDP实现TCP的可靠传输

1. 给数据包编号，按照包的顺序接收并存储
2. 接收端接收到数据包后发送确认信息给发送端，发送端接收确认数据以后再继续发送下一个包，如果接收端收到的数据包的编号不是期望的编号，则要求发送端重新发送

### TCP的三次握手

1. 首先客户端给服务端发送请求连接的报文 ACK = 0 SYN = 1 以及一个随机序号seq = x;
2. 再是服务端接受到客户端的报文，如果同意连接，则发送确认报文 ACK = 1,ack = x + 1,seq = y;
3. 最后是客户端接受到服务器的确认报文之后发送确认 ack = y + 1 seq = x + 1 ACK = 1;
   1. 建立连接
seq是序号，对字节流的编号

ack是确认号，一般是seq + 1;

ACK = 1的时候ack确认号才会生效

#### 为什么是三次握手不是两次

如果是**两次**握手，如果是客户端发送了一个**超时的报文**，一段时间之后**没接收到服务器的回应**，客户端会**再次发送一次报文**之后正常连接之后断开连接，但是之后如果服务端突然收到了这个超时的请求如果是两次握手就会**再次建立连接**，服务器会等待客户端的数据，这样就会很浪费资源。然而如果是三次握手，服务器在之后由于**接受不到客户端的再次确认报文**，服务器会自动关闭本次连接

### TCP四次挥手

由于TCP连接是**全双工通道**的，因此每个方向都必须单独进行关闭。这个原则是当一方完成它的数据发送任务后就能发送一个FIN来终止这个方向的连接。收到一个 FIN 意味着这一方向上没有数据流动，一个TCP连接在收到一个FIN后仍能发送数据。首先进行关闭的一方将执行主动关闭，而另一方执行被动关闭。

1. 客户端给服务器发送请求关闭连接的请求。FIN = 1 ,ACK = 0 ,seq = u;
2. 服务器接受到这个FIN返回一个确认。ACK = 1,seq = v,ack = u + 1;
   1. 此时，服务器就进入了CLOSE-WAIT（关闭等待）状态。TCP服务器通知高层的应用进程，客户端向服务器的方向就释放了，这时候处于**半关闭状态**，即客户端已经没有数据要发送了，但是服务器若发送数据，客户端依然要接受
3. 当服务器不需要和客户端的连接之后，发回一个FIN。FIN = 1,ACK = 1,seq = w,ack = u + 1;
4. 客户端发回ACK确认报文，ACK = 1,seq = u + 1,ack = w + 1;
   1. 此时客户端进入TIME_WAIT阶段
   2. 服务器接收到信息之后释放和客户端的连接

#### 为什么TIME_WAIT要等两个MSL再关闭

1. 为了防止服务端接收不到请求关闭连接的请求，则会在MSL时间内接收到超时重传的请求，再次发送。
2. 可以保证本次连接持续时间内所产生的所有报文都从网络中消失。

### TCP滑动窗口

TCP通过滑动窗口来实现，流量控制，控制发送方的发送速度。

![屏幕快照 2019-04-23 下午4.26.02](../photo/屏幕快照&#32;2019-04-23&#32;下午4.26.02.png)

### TCP的可靠传输

TCP通过超时重传实现可靠传输，如果一个已经发送的报文段在超时时间内没有收到确认，就重新发送这个报文段。

### TCP拥塞控制

存在着关键的四个算法

1. 慢开始
2. 拥塞避免
3. 快恢复
4. 快重传

#### 慢开始

在发送的最开始只发送一个报文段 cwnd = 1，然后每次翻倍然后是2、4、8…

#### 拥塞避免

设置了一个慢开始的门限ssthresh，当cwnd>=ssthresh的时候 cwnd的增长速度每次只+1；

* 当发生了超时重传的时候，令ssthresh = cwnd/2，然后重新开始慢开始

#### 快重传

在收到三个重复报文之后，则知道是下一个报文段丢失，因此执行快重传，立刻重传下一个报文段。

#### 快恢复

由于是报文丢失而不是网络拥塞，则执行快恢复令ssthresh = cwnd/2 但是cwnd = ssthresh，直接进入拥塞避免

### IP协议

通常TCP只是一个单独的传输协议，而TCP/IP协议不是IP，是网络层的协议（非常重要）
IP协议的作用是把各类数据包传输给对方，而要确保能确实的传输到对方哪里，就需要两个基础的条件1. IP地址（可更改） 2. MAC地址（网卡固定地址**不变**）

#### 使用ARP协议通过MAC地址进行通信

IP间的通信依赖MAC地址，而在网络上，通常是经过多台计算机和网络设备中转才能连接到对方。而在中转的时候，会利用下一站中转设备的MAC地址来搜索，这是会采用ARP协议，可根据IP地址解析MAC地址。

## 应用层

### DNS

* DNS是一个分布式数据库，提供主机地址和IP地址的转化。这里的分布式数据库是指的是每个站点只保留自己的那部分数据。
* DNS可以使用TCP或者UDP进行传输，但是大多数时间都是UDP。

### FTP

* FTP基于TCP的文件传输协议
* 需要有两个连接来传输一个文件
  * 控制连接
  * 传输连接

### DHCP

提供了即插即用的联网方式，用户不用手动配置IP地址信息

### TELNET（远程登陆协议）

利用TCP登录到主机

### 邮件传输协议

全是基于TCP/IP

#### SMTP

只能发送ASCII

#### POP3

只要用户从服务器上读取了邮件，就把邮件删除

#### IMAP

协议中的邮件和服务器上的邮件保持同步

## web请求的全过程

### DHCP 配置主机信息

1. 主机最开始没有IP地址以及其他的信息，需要通过DHCP获取
2. 首先生成一个DHCP的请求报文。再封装到具有目的端口和源端口的UDP报文中
3. 将报文段放入一个具有**广播IP目的地址**和**源IP地址**的IP数据报中
4. 再将该数据报放置在MAC帧中，该帧具有目的地址，将广播到与交换机连接的所有设备
5. 连接在交换机的DHCP的服务器收到广播帧之后，向上分解得到IP数据报，UDP数据报，DHCP请求报文，之后生成DHCP ACK报文，该报文包含以下信息：**IP地址**、**DNS服务器的IP地址**、**默认网关路由器的IP地址**和**子网掩码**。再类似的放在UDP报文中，IP报文中，最后放在MAC帧中。
6. 该帧的目的地址是主机的MAC地址，由于交换机有路由表，所以可以直接发回。
7. 主机收到该帧之后，不断分解得到DHCP报文，之后就配置它的IP地址，子网掩码和DNS服务器的IP地址，在其IP转发表中安装默认网关。

### ARP 解析 MAC 地址

1. 主机通过浏览器生成一个TCP的套接字，套接字向HTTP服务器发送HTTP请求。为了生成TCP套接字，主机要知道网站域名对应的IP地址
2. 主机生成一个DNS查询报文，改报文具有53号端口，因为DNS服务器的端口是53。
3. DNS查询报文被放到目的地址为DNS服务器IP地址的IP数据报中。
4. IP数据报被放到了一个以太网帧，将该帧发送到网关路由器。
5. DHCP只知道网关路由器的IP地址，为了获取网关路由器的MAC地址，还要使用ARP协议。
6. 主机生成一个包含目的地址为网关路由器IP地址的ARP查询报文，将ARP查询报文放入一个具有广播目的地址的以太网帧中，并向交换机发送该以太网帧，交换机将该帧转发给所有的链接设备，包括网关路由器。
7. 网关路由器接受到该帧之后，不断向上分解得到ARP报文，发现其中的IP地址和其接口的IP地址匹配，就返回一个ARP返回报文，包含了自己的MAC地址，发回给主机。

### DNS 解析域名

1. 知道了网关路由器的 MAC 地址之后，就可以继续 DNS 的解析过程了。
2. 网关路由器接收到包含 DNS 查询报文的以太网帧后，抽取出 IP 数据报，并根据转发表决定该 IP 数据报应该转发的路由器。
3. 因为路由器具有内部网关协议（RIP、OSPF）和外部网关协议（BGP）这两种路由选择协议，因此路由表中已经配置了网关路由器到达 DNS 服务器的路由表项。
4. 到达 DNS 服务器之后，DNS 服务器抽取出 DNS 查询报文，并在 DNS 数据库中查找待解析的域名。
5. 找到 DNS 记录之后，发送 DNS 回答报文，将该回答报文放入 UDP 报文段中，然后放入 IP 数据报中，通过路由器反向转发回网关路由器，并经过以太网交换机到达主机。

### 最后一步

1. 有了 HTTP 服务器的 IP 地址之后，主机就能够生成 TCP 套接字，该套接字将用于向 Web 服务器发送 HTTP GET 报文。
2. 在生成 TCP 套接字之前，必须先与 HTTP 服务器进行三次握手来建立连接。生成一个具有目的端口 80 的 TCP SYN 报文段，并向 HTTP 服务器发送该报文段。
3. HTTP 服务器收到该报文段之后，生成 TCP SYN ACK 报文段，发回给主机。
4. 连接建立之后，浏览器生成 HTTP GET 报文，并交付给 HTTP 服务器。
5. HTTP 服务器从 TCP 套接字读取 HTTP GET 报文，生成一个 HTTP 响应报文，将 Web 页面内容放入报文主体中，发回给主机。
6. 浏览器收到 HTTP 响应报文后，抽取出 Web 页面内容，之后进行渲染，显示 Web 页面。

### HTTPS的通信过程

1. 客户端打包请求。包括url，端口啊，你的账号密码等等。账号密码登陆应该用的是Post方式，所以相关的用户信息会被加载到body里面。这个请求应该包含三个方面：网络地址，协议，资源路径。注意，这里是HTTPS，就是HTTP + SSL / TLS，在HTTP上又加了一层处理加密信息的模块（相当于是个锁）。这个过程相当于是客户端请求钥匙。
2. 服务器接受请求。一般客户端的请求会先发送到DNS服务器。 DNS服务器负责将你的网络地址解析成IP地址，这个IP地址对应网上一台机器。这其中可能发生Hosts Hijack和ISP failure的问题。过了DNS这一关，信息就到了服务器端，此时客户端会和服务器的端口之间建立一个socket连接，socket一般都是以file descriptor的方式解析请求。这个过程相当于是服务器端分析是否要向客户端发送钥匙模板。
3. 服务器端返回数字证书。服务器端会有一套数字证书（相当于是个钥匙模板），这个证书会先发送给客户端。这个过程相当于是服务器端向客户端发送钥匙模板。
4. 客户端生成加密信息。根据收到的数字证书（钥匙模板），客户端会生成钥匙，并把内容锁上，此时信息已经加密。这个过程相当于客户端生成钥匙并锁上请求。
5. 客户端发送加密信息。服务器端会收到由自己发送出去的数字证书加锁的信息。 这个时候生成的钥匙也一并被发送到服务器端。这个过程是相当于客户端发送请求。
6. 服务器端解锁加密信息。服务器端收到加密信息后，会根据得到的钥匙进行解密，并把要返回的数据进行对称加密。这个过程相当于服务器端解锁请求、生成、加锁回应信息。
7. 服务器端向客户端返回信息。客户端会收到相应的加密信息。这个过程相当于服务器端向客户端发送回应。
8. 客户端解锁返回信息。客户端会用刚刚生成的钥匙进行解密，将内容显示在浏览器上。

## HTTP

超文本传输协议(HTTP)用于从万维网服务器传输超文本到本地浏览器的传送协议，是建立于TCP协议之上的一种应用。

### URI

**URI**：Uniform Resource Identifier，即统一资源标志符，用来唯一的标识一个资源。（HTTP协议使URI定位互联网上的资源）

* 绝对URI格式：`http://user:pass@www.example.jp:80/dir/index.htm?uid=1#ch1`
  * 协议名://登录信息@服务器地址:端口号/带层次的文件路径?查询字符串#片段标识符
  * 登录信息（可选）
  * 服务器地址 DNS可解析域名|IPV4|[IPV6](方括号括起来的IPV6)
  * 端口号（省略自动使用默认端口）
  * 查询字符串（可选）
  * 片段表示（可选）
**URL**：Uniform Resource Locator，统一资源定位符。即URL可以用来标识一个资源，而且还指明了如何locate这个资源。

**URN**：Uniform Resource Name，统一资源命名。即通过名字来表示资源的。

### HTTP中的方法

客户端发送的 请求报文 第一行为请求行，包含了方法字段。

1. GET：GET方法主要用于请求访问已被URI识别的资源
2. POST：主要用传输实体的信息
3. PUT：用于上传文件
4. DELETE：和PUT相反，用于删除文件
   * PUT&&DELETE都没有验证机制**不安全**
5. HEAD：和GET一样，只是不返回报文主体部分，用于确认URI的有效性以及资源更新的日期时间
**下面6，7，8不适用与HTTP1.0**
6. OPTIONS：用于查询针对URI指定资源的支持的方法
7. TRACE：服务器会将通讯地址返回给客户端
   * 不安全，容易遭到XST攻击（跨站追踪）
8. CONNECT：CONNECT方法要求在与代理服务器通信时建立隧道，实现用隧道协议进行TCP通信，主要使用SSL（安全套接层）和TSL（传输层安全）将内容加密传输

### 状态码

1. 1XX 信息性状态码--接受的请求正在处理
   1. 100 continue
2. 2XX 成功--请求正常处理完毕
   1. 200 OK  表示从客户端发送过来的请求在服务器端被正常处理了
   2. 204 No Content 请求处理成功，但是没有资源可以返回
   3. 206 Partial Content 该状态码表示客户端进行了范围请求
3. 3XX 重定向--需要进行附加操作以完成请求
   1. 301 Moved Permanently 永久重定向 表示请求的资源已经被分配了新的URI，以后使用新的访问
   2. 302 Found 临时重定向 该状态码表示请求的资源已被分配了新的URI，希望使用新的URI访问
   3. 303 See Other 表示由于请求对应的资源存在着另一个URI 应使用get定向过去请求的资源
   4. 307 Temporary Redirect 临时重定向 和302含义相似，但是307要求浏览器
4. 4XX 客户端错误--服务器无法处理请求
   1. 400 Bad Request 客户端请求有语法错误
   2. 401 Unauthorized 状态码表示发送的请求要有认证信息
   3. 403 Forbidden  请求资源的访问被服务器拒绝了
   4. 404 not Found
5. 5XX 服务器错误--服务器处理请求出错
   1. 500 Internal Server Error 服务器正在执行请求时发生错误
   2. 503 Serveice Unavailable  服务器暂时处于超负载或正在进行停机维护

### HTTP通信数据转发

HTTP除了客户端和服务器之间，中间还有三种帮助通信的方式

1. 代理
2. 网关
3. 隧道

#### 代理

* 代理是一种具有转发功能的应用程序，它扮演了位于服务器和客户端之间“中间人”的角色，接收由客户端发送的请求并转发给服务器，同时也接收服务器返回的响应并转发给客户端。通过中间的代理服务器进行，进一步的通信。（**每次通过代理转发，会增加Via首部信息**）

1. 缓存代理
   1. 代理转发响应的时候，缓存代理会预先将资源的副本保存在缓存服务器上，当再次接收到相同资源的请求
   2. 可不从服务器那端获取，而是将之前的直接返回
2. 透明代理
   1. 不对报文进行加工的就是透明代理

##### 缓存的有效期

即使缓存服务器，存在缓存，也会因为客户端的要求，缓存的有效期，向源服务器确认资源的有效性，若判断缓存失效，缓存服务器会再次从源服务器上获取新的资源。

#### 网关

* 网关是转发其他服务器通信数据的服务器，接收从客户端发送来的请求时，它就像自己拥有资源的资源服务器一样对请求进行 处理。有时候客户端都不会察觉，自己的通信目标是一个网关。
网关类似于代理，但是可以让服务器提供其他的非HTTP协议的通信，可以说是协议转换器，在OSI7层中从传输层之上都是网关。

#### 隧道

* 隧道是在相隔甚远的客户端和服务器两者之间进行中转，并保持双方通信连接的应用程序。
隧道使用的是TSL和SSL加密，可以确保数据的安全通信。

### HTTP1.0和1.1

* HTTP1.0是短连接的，每次请求数据都要新建一个TCP的长连接，开销会很大
* HTTP1.1之后默认是长连接的，只要任意一端没有明确提出断开连接，则保持TCP状态。
  * 好处在于减少了建立TCP连接的重复建立，和断开所造成的额外开销，减轻了服务器端的开销。

> 流水线 默认情况下HTTP是按顺序发出的，下个请求只有在当前响应之后才会发出，会被网络延迟和宽带限制，在1.1之后建立长链接之后流水线是在同一长连接上发出连续的请求，而不用等待响应返回。

#### Cookie

HTTP1.1引入Cookie来保存状态信息。Cookie是服务器发送到用户浏览器并保存在本地的一块小数据，它会在浏览器之后向同一服务器再次发起请求时携带上。Cookie会根据服务器端发送的响应报文内一个叫Set-Cookie的首部字段信息，通知客户端保存Cookie，然后客户端返回一个带cookie首部的请求。
注：Cookie现在逐渐被淘汰，**因为新的浏览器API可以允许开发者直接将数据储存到本地**。

#### Session

除了Cookie可以将用户信息储存在本地，也可以利用Session储存在服务器端，储存在服务器的信息更加安全。

##### Cookie和Session

1. Cookie 只能存储 ASCII 码字符串，而 Session 则可以存取任何类型的数据，因此在考虑数据复杂性时首选 Session；
2. Cookie 存储在浏览器中，容易被恶意查看。如果非要将一些隐私数据存在 Cookie 中，可以将 Cookie 值进行加密，然后在服务器进行解密；
3. 对于大型网站，如果用户所有的信息都存储在 Session 中，那么开销是非常大的，因此不建议将所有的用户信息都存储到 Session 中。

### HTTP的首部

#### 请求行|响应行

请求方法 + 请求URI + 协议版本
响应结果状态码 + 原因短语 + 协议版本

#### 请求首部|响应首部

#### 通用首部

#### 实体首部

#### 空行CR + LF（回车 + 换行）

### HTTPS

使用 SSL（Secure Sockets Layer，安全套接层）和 TLS（Transport Layer Security，传输层安全）协议把通信内容加密后经网络隧道传输。

#### 加密过程

1. 对称加密
   1. 加密和解密使用同一秘钥
   2. 非对称加密
      1. 加密和解密使用不同的秘钥
      2. 公开秘钥所有人可以获得，再接收方接收到通信内容后使用私有秘钥解密。
HTTPS使用混合加密机制，通过使用非对称秘钥加密用于传输对称秘钥来保证传输过程的安全性，之后使用对称秘钥进行通信来保证通信过程的效率

#### 区别

相比HTTP需要进行加密，速度会更慢
需要支付证书授权的的高额费用

### 如果DNS服务器返回了错误的IP如何去处理

1. 在APP发布的时候内置一个默认的IP
2. 在启动APP|网络变化的时候解析域名
3. 查看解析结果
   1. 如果不能解析的话用一个默认的IP代替
   2. 如果解析成功为8.8.8.8，为了防止解析结果错误，可以采用一个检测接口，调用之后根据响应结果HTTP Response，检测api是否正确
      1. 如果api正常就使用这个域名进行请求，而且将默认IP修改8.8.8.8
      2. 如果不正常就使用默认IP
